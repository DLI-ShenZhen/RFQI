# if( Sys.info()[['sysname']] == 'Windows' ){
#   message(paste(
#     "\n",
#     "   *** Microsoft Windows detected ***\n",
#     "   \n",
#     "   For technical reasons, the MS Windows version of mclapply()\n",
#     "   is implemented as a serial function instead of a parallel\n",
#     "   function.",
#     "   \n\n",
#     "   As a quick hack, we replace this serial version of mclapply()\n",
#     "   with a wrapper to parLapply() for this R session. Please see\n\n",
#     "     https://www.r-bloggers.com/implementing-mclapply-on-windows-a-primer-on-embarrassingly-parallel-computation-on-multicore-systems-with-r/
#  \n\n",
#     "   for details.\n\n"))
# }
#' mclapply
#'
#' If the OS is Windows, set mclapply to the
#' the hackish version. Otherwise, leave the
#' definition alone.
mclapply <- switch( Sys.info()[['sysname']],
Windows = {mclapply.hack},
Linux   = {mclapply},
Darwin  = {mclapply})
registerPackage(cl_1)
parLapply(cl_1, 1, function(x){require(future)})
if (is.null(idx)) idx=getFeatureHasMS2(MS2DB=MS2DB, n=n)
min(c(1,2,3))
min(c(2,3,4))
min(c(5,2,3,4))
min(5,3,4,56)
#' @param idx if assigned, only compute MS2 similarity matrix of this feature
#' @param MS2DB db.MS2 object
#' @param n minumum number of MS2 features should have, default is 2
#' @param cores1 numeric threads for idx parallel computing, e.g. simultaneously analysis cores1 feature
#' @param cores2 numeric threads for parallel computing MS2 similarity belonging to the same feature
#' @param ppm m/z tolerance of MS2
#' @param sn signal to noise ratio
#' @param maxMS2 the max number of MS2 belonging to one feature for computing similarity; if appointed, will random select maxMS2 number MS2
#' @return list, names of list are feature name, and elements are MS2 similarity matrix of MS2 belonging to the feature
#' @export
get_ms2Cor_inner = function(MS2DB, idx=NULL, n=2, cores1=1, cores2=3, ppm=30, sn=3, maxMS2=200){
cores1 = min(cores1, availableCores()-1); cl_1 = makeCluster(cores1);
registerPackage(cl_1); registerParentVars(cl_1)
cores2 = min(cores2, availableCores()-1); cl_2 = makeCluster(cores2);
registerPackage(cl_2); registerParentVars(cl_2)
if (is.null(idx)) idx=getFeatureHasMS2(MS2DB=MS2DB, n=n)
result = parLapply(cl_1, idx, function(id){
MS2_set = checkMS2(id, MS2DB = MS2DB)$MS2
if (!is.null(maxMS2)){
if (length(MS2_set) > maxMS2) MS2_set = sample(MS2_set, maxMS2)
}
corMatrix = get_multiple_ms2Cor(MS2_set = MS2_set, cl=cl_2, ppm=ppm, sn=sn)
rownames(corMatrix) = colnames(corMatrix) = names(MS2_set)
corMatrix
})
names(result) = idx
stopCluster(cl)
return(result)
}
startTime = Sys.time()
get_ms2Cor_inner(MS2DB = MS2DB, cores1=2, cores2=2)
#' @param idx if assigned, only compute MS2 similarity matrix of this feature
#' @param MS2DB db.MS2 object
#' @param n minumum number of MS2 features should have, default is 2
#' @param cores1 numeric threads for idx parallel computing, e.g. simultaneously analysis cores1 feature
#' @param cores2 numeric threads for parallel computing MS2 similarity belonging to the same feature
#' @param ppm m/z tolerance of MS2
#' @param sn signal to noise ratio
#' @param maxMS2 the max number of MS2 belonging to one feature for computing similarity; if appointed, will random select maxMS2 number MS2
#' @return list, names of list are feature name, and elements are MS2 similarity matrix of MS2 belonging to the feature
#' @export
get_ms2Cor_inner = function(MS2DB, idx=NULL, n=2, cores1=1, cores2=3, ppm=30, sn=3, maxMS2=200){
cores1 = min(cores1, availableCores()-1); cl_1 = makeCluster(cores1);
registerPackage(cl_1); registerParentVars(cl_1)
if (is.null(idx)) idx=getFeatureHasMS2(MS2DB=MS2DB, n=n)
result = parLapply(cl_1, idx, function(id){
MS2_set = checkMS2(id, MS2DB = MS2DB)$MS2
if (!is.null(maxMS2)){
if (length(MS2_set) > maxMS2) MS2_set = sample(MS2_set, maxMS2)
}
cores2 = min(cores2, availableCores()-1); cl_2 = makeCluster(cores2);
clusterEvalQ(cl_2, "require(RFQI)")
corMatrix = get_multiple_ms2Cor(MS2_set = MS2_set, cl=cl_2, ppm=ppm, sn=sn)
rownames(corMatrix) = colnames(corMatrix) = names(MS2_set)
corMatrix
})
names(result) = idx
stopCluster(cl_2)
stopCluster(cl_2)
return(result)
}
get_ms2Cor_inner(MS2DB = MS2DB, cores1=2, cores2=2)
#' @param idx if assigned, only compute MS2 similarity matrix of this feature
#' @param MS2DB db.MS2 object
#' @param n minumum number of MS2 features should have, default is 2
#' @param cores1 numeric threads for idx parallel computing, e.g. simultaneously analysis cores1 feature
#' @param cores2 numeric threads for parallel computing MS2 similarity belonging to the same feature
#' @param ppm m/z tolerance of MS2
#' @param sn signal to noise ratio
#' @param maxMS2 the max number of MS2 belonging to one feature for computing similarity; if appointed, will random select maxMS2 number MS2
#' @return list, names of list are feature name, and elements are MS2 similarity matrix of MS2 belonging to the feature
#' @export
get_ms2Cor_inner = function(MS2DB, idx=NULL, n=2, cores1=1, cores2=3, ppm=30, sn=3, maxMS2=200){
cores1 = min(cores1, availableCores()-1); cl_1 = makeCluster(cores1);
registerPackage(cl_1); registerParentVars(cl_1)
if (is.null(idx)) idx=getFeatureHasMS2(MS2DB=MS2DB, n=n)
result = parLapply(cl_1, idx, function(id){
MS2_set = checkMS2(id, MS2DB = MS2DB)$MS2
if (!is.null(maxMS2)){
if (length(MS2_set) > maxMS2) MS2_set = sample(MS2_set, maxMS2)
}
cores2 = min(cores2, availableCores()-1)
cl_2 = makeCluster(cores2)
clusterEvalQ(cl_2, "require(RFQI)")
corMatrix = get_multiple_ms2Cor(MS2_set = MS2_set, cl=cl_2, ppm=ppm, sn=sn)
rownames(corMatrix) = colnames(corMatrix) = names(MS2_set)
corMatrix
stopCluster(cl_2)
})
names(result) = idx
stopCluster(cl_2)
return(result)
}
get_ms2Cor_inner(MS2DB = MS2DB, cores1=2, cores2=2)
#' @param idx if assigned, only compute MS2 similarity matrix of this feature
#' @param MS2DB db.MS2 object
#' @param n minumum number of MS2 features should have, default is 2
#' @param cores1 numeric threads for idx parallel computing, e.g. simultaneously analysis cores1 feature
#' @param cores2 numeric threads for parallel computing MS2 similarity belonging to the same feature
#' @param ppm m/z tolerance of MS2
#' @param sn signal to noise ratio
#' @param maxMS2 the max number of MS2 belonging to one feature for computing similarity; if appointed, will random select maxMS2 number MS2
#' @return list, names of list are feature name, and elements are MS2 similarity matrix of MS2 belonging to the feature
#' @export
get_ms2Cor_inner = function(MS2DB, idx=NULL, n=2, cores1=1, cores2=3, ppm=30, sn=3, maxMS2=200){
cores1 = min(cores1, availableCores()-1); cl_1 = makeCluster(cores1);
registerPackage(cl_1); registerParentVars(cl_1)
if (is.null(idx)) idx=getFeatureHasMS2(MS2DB=MS2DB, n=n)
result = parLapply(cl_1, idx, function(id){
MS2_set = checkMS2(id, MS2DB = MS2DB)$MS2
if (!is.null(maxMS2)){
if (length(MS2_set) > maxMS2) MS2_set = sample(MS2_set, maxMS2)
}
cores2 = min(cores2, availableCores()-1)
cl_2 = makeCluster(cores2)
clusterEvalQ(cl_2, "require(RFQI)")
corMatrix = get_multiple_ms2Cor(MS2_set = MS2_set, cl=cl_2, ppm=ppm, sn=sn)
rownames(corMatrix) = colnames(corMatrix) = names(MS2_set)
corMatrix
stopCluster(cl_2)
})
names(result) = idx
stopCluster(cl_1)
return(result)
}
get_ms2Cor_inner(MS2DB = MS2DB, cores1=2, cores2=2)
MS2DB
MS2DB = db.MS2
get_ms2Cor_inner(MS2DB = MS2DB, cores1=2, cores2=2)
#' @param idx if assigned, only compute MS2 similarity matrix of this feature
#' @param MS2DB db.MS2 object
#' @param n minumum number of MS2 features should have, default is 2
#' @param cores1 numeric threads for idx parallel computing, e.g. simultaneously analysis cores1 feature
#' @param cores2 numeric threads for parallel computing MS2 similarity belonging to the same feature
#' @param ppm m/z tolerance of MS2
#' @param sn signal to noise ratio
#' @param maxMS2 the max number of MS2 belonging to one feature for computing similarity; if appointed, will random select maxMS2 number MS2
#' @return list, names of list are feature name, and elements are MS2 similarity matrix of MS2 belonging to the feature
#' @export
get_ms2Cor_inner = function(MS2DB, idx=NULL, n=2, cores1=1, cores2=3, ppm=30, sn=3, maxMS2=200){
cores1 = min(cores1, availableCores()-1); cl_1 = makeCluster(cores1);
registerPackage(cl_1); registerParentVars(cl_1)
if (is.null(idx)) idx=getFeatureHasMS2(MS2DB=MS2DB, n=n)
result = parLapply(cl_1, idx, function(id){
MS2_set = checkMS2(id, MS2DB = MS2DB)$MS2
if (!is.null(maxMS2)){
if (length(MS2_set) > maxMS2) MS2_set = sample(MS2_set, maxMS2)
}
cores2 = min(cores2, availableCores()-1)
cl_2 = makeCluster(cores2)
registerPackage(cl_2)
corMatrix = get_multiple_ms2Cor(MS2_set = MS2_set, cl=cl_2, ppm=ppm, sn=sn)
rownames(corMatrix) = colnames(corMatrix) = names(MS2_set)
corMatrix
stopCluster(cl_2)
})
names(result) = idx
stopCluster(cl_1)
return(result)
}
get_ms2Cor_inner(MS2DB = MS2DB, cores1=2, cores2=2)
cores1 = min(cores1, availableCores()-1)
cl_1 = makeCluster(cores1)
registerPackage(cl_1)
registerParentVars(cl_1)
parLapply(cl_1, 1, function(x){checkMS2})
parLapply(cl_1, 1, function(x){checkMS2()})
clusterExport(cl=cl_1, "checkMS2")
parLapply(cl_1, 1, function(x){checkMS2()})
parLapply(cl_1, 1, function(x){checkMS2})
#' @param idx if assigned, only compute MS2 similarity matrix of this feature
#' @param MS2DB db.MS2 object
#' @param n minumum number of MS2 features should have, default is 2
#' @param cores1 numeric threads for idx parallel computing, e.g. simultaneously analysis cores1 feature
#' @param cores2 numeric threads for parallel computing MS2 similarity belonging to the same feature
#' @param ppm m/z tolerance of MS2
#' @param sn signal to noise ratio
#' @param maxMS2 the max number of MS2 belonging to one feature for computing similarity; if appointed, will random select maxMS2 number MS2
#' @return list, names of list are feature name, and elements are MS2 similarity matrix of MS2 belonging to the feature
#' @export
get_ms2Cor_inner = function(MS2DB, idx=NULL, n=2, cores1=1, cores2=3, ppm=30, sn=3, maxMS2=200){
cores1 = min(cores1, availableCores()-1)
cl_1 = makeCluster(cores1)
registerPackage(cl_1)
registerParentVars(cl_1)
clusterExport(cl=cl_1, "checkMS2")
if (is.null(idx)) idx=getFeatureHasMS2(MS2DB=MS2DB, n=n)
result = parLapply(cl_1, idx, function(id){
MS2_set = checkMS2(id, MS2DB = MS2DB)$MS2
if (!is.null(maxMS2)){
if (length(MS2_set) > maxMS2) MS2_set = sample(MS2_set, maxMS2)
}
cores2 = min(cores2, availableCores()-1)
cl_2 = makeCluster(cores2)
registerPackage(cl_2)
corMatrix = get_multiple_ms2Cor(MS2_set = MS2_set, cl=cl_2, ppm=ppm, sn=sn)
rownames(corMatrix) = colnames(corMatrix) = names(MS2_set)
corMatrix
stopCluster(cl_2)
})
names(result) = idx
stopCluster(cl_1)
return(result)
}
get_ms2Cor_inner(MS2DB = MS2DB, cores1=2, cores2=2)
clusterEvalQ(cl=cl_1, "require(future)")
parLapply(cl_1, 1, function(x){availableCores})
clusterEvalQ(cl=cl_1, require(future))
parLapply(cl_1, 1, function(x){availableCores})
stopCluster(cl_1)
cores1 = min(cores1, availableCores()-1)
cl_1 = makeCluster(cores1)
registerPackage(cl_1)
parLapply(cl_1, 1, function(){availableCores})
parLapply(cl_1, 1, function(x){availableCores})
#' registerPackage
#'
#' register packages into cluster
registerPackage = function(cl){
pkg.names <- c(
## Base packages
sessionInfo()$basePkgs,
## Additional packages
names( sessionInfo()$otherPkgs ))
for (i in pkg.names){
clusterEvalQ(cl, require(x))
}
# lapply(pkg.names, function(x){
#   clusterEvalQ(cl, require(x))
# })
}
registerPackage(cl_1)
parLapply(cl_1, 1, function(x){availableCores})
registerPackage
stopCluster(cl_1)
#' registerPackage
#'
#' register packages into cluster
registerPackage = function(cl){
pkg.names <- c(
## Base packages
sessionInfo()$basePkgs,
## Additional packages
names( sessionInfo()$otherPkgs ))
parLapply(cl, 1:length(cl), function(xx){
lapply(pkg.names, function(yy) {
require(yy , character.only=TRUE)})
})
# for (i in pkg.names){
#   clusterEvalQ(cl, require(x))
# }
# lapply(pkg.names, function(x){
#   clusterEvalQ(cl, require(x))
# })
}
cores1 = min(cores1, availableCores()-1)
cl_1 = makeCluster(cores1)
registerPackage(cl_1)
parLapply(cl_1, 1, function(x){availableCores})
#' @param idx if assigned, only compute MS2 similarity matrix of this feature
#' @param MS2DB db.MS2 object
#' @param n minumum number of MS2 features should have, default is 2
#' @param cores1 numeric threads for idx parallel computing, e.g. simultaneously analysis cores1 feature
#' @param cores2 numeric threads for parallel computing MS2 similarity belonging to the same feature
#' @param ppm m/z tolerance of MS2
#' @param sn signal to noise ratio
#' @param maxMS2 the max number of MS2 belonging to one feature for computing similarity; if appointed, will random select maxMS2 number MS2
#' @return list, names of list are feature name, and elements are MS2 similarity matrix of MS2 belonging to the feature
#' @export
get_ms2Cor_inner = function(MS2DB, idx=NULL, n=2, cores1=1, cores2=3, ppm=30, sn=3, maxMS2=200){
cores1 = min(cores1, availableCores()-1)
cl_1 = makeCluster(cores1)
registerPackage(cl_1)
registerParentVars(cl_1)
clusterExport(cl=cl_1, "checkMS2")
if (is.null(idx)) idx=getFeatureHasMS2(MS2DB=MS2DB, n=n)
result = parLapply(cl_1, idx, function(id){
MS2_set = checkMS2(id, MS2DB = MS2DB)$MS2
if (!is.null(maxMS2)){
if (length(MS2_set) > maxMS2) MS2_set = sample(MS2_set, maxMS2)
}
cores2 = min(cores2, availableCores()-1)
cl_2 = makeCluster(cores2)
registerPackage(cl_2)
corMatrix = get_multiple_ms2Cor(MS2_set = MS2_set, cl=cl_2, ppm=ppm, sn=sn)
rownames(corMatrix) = colnames(corMatrix) = names(MS2_set)
corMatrix
stopCluster(cl_2)
})
names(result) = idx
stopCluster(cl_1)
return(result)
}
get_ms2Cor_inner(MS2DB = MS2DB, cores1=2, cores2=2)
str(db.MS2)
#' @param idx if assigned, only compute MS2 similarity matrix of this feature
#' @param MS2DB db.MS2 object
#' @param n minumum number of MS2 features should have, default is 2
#' @param cores1 numeric threads for idx parallel computing, e.g. simultaneously analysis cores1 feature
#' @param cores2 numeric threads for parallel computing MS2 similarity belonging to the same feature
#' @param ppm m/z tolerance of MS2
#' @param sn signal to noise ratio
#' @param maxMS2 the max number of MS2 belonging to one feature for computing similarity; if appointed, will random select maxMS2 number MS2
#' @return list, names of list are feature name, and elements are MS2 similarity matrix of MS2 belonging to the feature
#' @export
get_ms2Cor_inner = function(MS2DB, idx=NULL, n=2, cores1=1, cores2=3, ppm=30, sn=3, maxMS2=200){
cores1 = min(cores1, availableCores()-1)
cl_1 = makeCluster(cores1)
registerPackage(cl_1)
registerParentVars(cl_1)
clusterExport(cl=cl_1, "checkMS2")
if (is.null(idx)) idx=getFeatureHasMS2(MS2DB=MS2DB, n=n)
result = parLapply(cl_1, idx, function(id){
MS2_set = checkMS2(id, MS2DB = MS2DB)$MS2
if (!is.null(maxMS2)){
if (length(MS2_set) > maxMS2) MS2_set = sample(MS2_set, maxMS2)
}
cores = min(cores2, availableCores()-1)
if (length(MS2_set) < 100 & length(MS2_set)>50) cores = 2
if (length(MS2_set) <= 50) cores = 1
cl_2 = makeCluster(cores)
registerPackage(cl_2)
corMatrix = get_multiple_ms2Cor(MS2_set = MS2_set, cl=cl_2, ppm=ppm, sn=sn)
rownames(corMatrix) = colnames(corMatrix) = names(MS2_set)
corMatrix
stopCluster(cl_2)
})
names(result) = idx
stopCluster(cl_1)
return(result)
}
MS2DB = list(MS2=db.MS2$[1:1000], MS2_to_MS1=db.MS2$MS2_to_MS1[1:1000,])
get_ms2Cor_inner(MS2DB = MS2DB, cores1=2, cores2=2)
# --- MS2 similarity algorithm --- #
#' translate Da to ppm
#'
#' Calculating difference of two m/z, then convert diff into ppm
#'
#' @param mz numeric vector, m/z values sorted by inreasing
#' @param mz.ppm.thr numeric, threshold of ppm difference
#' @return vector, ppm difference of m/z with the first m/z
#' @examples
#' \donttest{
#'   GetDiffMZppm(c(100.01,100.02, 100.03))
#' }
GetDiffMZppm <- function(mz, mz.ppm.thr = NULL) {
mz.diff <- diff(mz) / mz[-1] * 1e6
if (!is.null(mz.ppm.thr)) {
idx <- which(mz[-1] <= mz.ppm.thr)
mz.diff[idx] <- mz.diff[idx] * mz[-1][idx] / mz.ppm.thr
}
mz.diff
}
#' group m/z based on m/z tolerance
#'
#' As MassSpectrometry has fluctuate in m/z detection, one ion can be detected as two similar m/z, thus we need to combine these two m/z.
#' After Combining, m/z is the mean, and intensity is the sum.
#' @param spec numeric matrix, columns are "mz" and "intensity", represents an MS2 spectrum
#' @param ppm.ms2match numeric, m/z tolerance of MS2 in ppm mode
#' @param mz.ppm.thr used in GetDiffMZppm function
#' @return MS2 spectrum
MatchSpec <- function(spec, ppm.ms2match = 30, mz.ppm.thr = 400) {
while (TRUE) {
mz.diff.ppm <- GetDiffMZppm(spec[, 'mz'], mz.ppm.thr = mz.ppm.thr)
idx <- which(mz.diff.ppm < ppm.ms2match)
if (length(idx) > 0) {
i <- tail(idx, 1)
j <- which.max(spec[c(i, i + 1), 'intensity'])
spec[i, 'intensity'] <- spec[i + j - 1, 'intensity']
i2 <- i + 1
spec[i, 'mz'] <- spec[i2, 'mz']
spec <- spec[-i - 1, , drop = FALSE]
} else {
break
}
}
return(spec)
}
#' combine two MS2 spectrum based on m/z
#'
#' @param spec.exp MS2 spectrum
#' @param spec.lib MS2 spectrum
#' @param ppm.ms2match m/z tolerance of MS2
#' @return list, contains m/z alignment exp and lib spectrum
GetSpec2Match <- function(spec.exp, spec.lib, ppm.ms2match = 30) {
# align m/z of spec.exp and spec.lib
mz.pool   <- sort(c(spec.exp[, 1], spec.lib[, 1]))	# combine mz
spec.exp.pool = spec.lib.pool = cbind('mz' = mz.pool, 'intensity' = 0)		# construct alignment matrix
spec.exp.pool[match(spec.exp[,1], spec.exp.pool), "intensity"] = spec.exp[,2]
spec.lib.pool[match(spec.lib[,1], spec.lib.pool), "intensity"] = spec.lib[,2]
# combine nearby peaks
pk.spec  <- MatchSpec(spec.exp.pool, ppm.ms2match = ppm.ms2match)	# combine adjacent m/z if GetDiffMZppm < pps.ms2match)
lib.spec <- MatchSpec(spec.lib.pool, ppm.ms2match = ppm.ms2match)	# combine adjacent m/z if GetDiffMZppm < pps.ms2match)
return(list('exp' = pk.spec, 'lib' = lib.spec))
}
#' compute cosine similarity of two MS2 spectrum
#'
#' @param spec.exp experimental MS2 spectrum, columns are "mz" and "intensity"
#' @param spec.lib reference MS2 spectrum, columns are "mz" and "intensity"
#' @param sn signal to noise ratio
#' @param ppm m/z tolerence of MS2
#' @return cosine similarity of spec.exp and spec.lib
#' @export
GetMatchResult = function(spec.exp, spec.lib, sn=3, ppm=30){
# spec.lib=a; spec.exp=b; sn=10
colnames(spec.lib)=colnames(spec.exp)=c("mz","intensity")
mode(spec.lib) = mode(spec.exp) = "numeric"
spec.lib[,2] = spec.lib[,2]/max(spec.lib[,2])*100
spec.exp[,2] = spec.exp[,2]/max(spec.exp[,2])*100
spec.lib.filter = spec.lib[spec.lib[,2]>sn,,drop=FALSE]
spec.exp.filter = spec.exp[spec.exp[,2]>sn,,drop=FALSE]
# combine spec.lib and spec.exp
spec2match <- GetSpec2Match(spec.exp, spec.lib,                               # GetSpec2Match returns match(spec.exp, spec.exp+spec.lib) for "exp"
ppm.ms2match = ppm)			# and match(spec.lib, spec.exp+spec.lib) + spec.exp for "lib"
# compute cosine similarity
int.spec = spec2match$exp[,"intensity"]
int.lib = spec2match$lib[,"intensity"]
score = sum(int.spec*int.lib)/sqrt(sum(int.spec^2) * sum(int.lib^2))
return(score)
}
#' compute pair cosine similarity score of multiple MS2
#'
#' @aliases get_MS2_cor_inner
#' @param MS2_set a list whose elements are MS2 spectrum
#' @param cores numeric for parallel computing
#' @param cl cluster generate by parallel::makecluster, if cl is NULL, then use cores to makeCluster
#' @param ppm m/z tolerance
#' @param sn signal to noise ratio
#' @return a similarity score matrix
#' @export
get_multiple_ms2Cor = function(MS2_set, cores=2, cl=NULL, ppm=30, sn=3){
closeCluster = FALSE
if (is.null(cl)){
if (cores >= availableCores()) cores=availableCores()-1
cl = makeCluster(cores)
registerPackage(cl)
closeCluster = TRUE
}
registerParentVars(cl)
score = parLapply(cl, 1:(length(MS2_set)-1), function(i){
spec.exp = MS2_set[[i]]; colnames(spec.exp)[1:2] = c("mz", "intensity")
# compare spec.exp with it's latter MS2
score1 = lapply(MS2_set[(i+1):length(MS2_set)], function(y){
if (is.null(y)) return(0)
spec.lib = y; colnames(spec.lib)[1:2] = c("mz","intensity")
if (nrow(spec.exp)==0 | nrow(spec.lib)==0) return(0)
score1 = GetMatchResult(spec.exp=spec.exp, spec.lib=spec.lib, ppm=30, sn=3)
return(score1)
})
score2 = unlist(score1)
return(score2)
})
if (closeCluster) {stopCluster(cl)}
result = matrix(nrow=length(MS2_set), ncol=length(MS2_set))
for (i in 1:length(score)){
result[i,(i+1):ncol(result)] = score[[i]]
}
result[lower.tri(result)] = result[upper.tri(result)]
return(result)
}
mclapply(1:2, function(x){availableCores}, mc.cores=2)
startTime = Sys.time()
# get_ms2Cor_inner(MS2DB = MS2DB, cores1=2, cores2=2)
# group_FT.split_data = lapply(split_data, getPeakRange_singFile, cores=cores, param=param)
mclapply(1:20, function(x){availableCores()}, mc.cores=2)
endTime = Sys.time()
duration = (as.numeric(endTime) - as.numeric(startTime))/60
print(duration)
startTime = Sys.time()
# get_ms2Cor_inner(MS2DB = MS2DB, cores1=2, cores2=2)
# group_FT.split_data = lapply(split_data, getPeakRange_singFile, cores=cores, param=param)
mclapply(1:20, function(x){
mclapply(1:10, function(y){availableCores()}, mc.cores = 2)
}, mc.cores=2)
endTime = Sys.time()
duration = (as.numeric(endTime) - as.numeric(startTime))/60
print(duration)
devtools::document()
library(RFQI)
RFQI::platform
devtools::document()
